# -*- coding: utf-8 -*-
"""XTSTree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m6ahpjT1oVUA1umLLq_Vxr3aTZHE0L3Q
"""

# Commented out IPython magic to ensure Python compatibility.

import math
import time
import numpy as np
import random
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA as statsARIMA
from collections.abc import Iterable
import matplotlib.pyplot as plt
from skmultiflow.drift_detection import PageHinkley

def plot(vals, labels=None, detected_anomalies=[], continuous_anomalies=[], margins=None, title='', save=False, img_name=None, show=True, divisions=[], sec_plots=[], figsize=(4,2)):
  X=range(len(vals))
  max_y, min_y = max([max(vals), *[max(sec_val) for sec_val in sec_plots]]), min([min(vals), *[min(sec_val) for sec_val in sec_plots]])
  fig, ax = plt.subplots(figsize=figsize, dpi=360)
  ax.set_title(title)
  plt.plot(vals)
  if labels:
    plt.xticks([label[0] for label in labels], [label[1] for label in labels], rotation=45)
  for subplot in sec_plots:
    plt.plot(subplot)
  for i in detected_anomalies:
    plt.scatter(i, vals[i], s=800, marker="x", color="r", alpha=0.6)
  anom_dev = max_y - min_y
  for i in continuous_anomalies:
    anom_top_margins = []
    anom_bottom_margins = []
    for point in range(i[0], i[1]):
      anom_top_margins.append(vals[point]+anom_dev)
      anom_bottom_margins.append(vals[point]-anom_dev)
    plt.fill_between(range(i[0], i[1]), anom_top_margins, anom_bottom_margins, alpha = 0.7, color="r", interpolate=True)
  plt.fill_between(
    [i for i in range(len(vals))],
    [max_y for i in range(len(vals))],
    [min_y for i in range(len(vals))],
    where=[True if i in divisions else False for i in range(len(vals))],
    color='grey', linestyle='--', alpha=0.5
  )
  j = 0
  if margins:
    for margin in margins:
      plt.fill_between(range(len(vals)), margin[0], margin[1], alpha = 0.1, color="b")
  fig.tight_layout()
  if save:
    fig.savefig(img_name if img_name is not None else title, bbox_inches='tight')
  if show:	
     plt.show()
  else:
    plt.close(fig)

"""Estrutura de árvore"""

class TreeNode:
  pass
class TreeNode:

  def __init__(self, content):
    self.left = None
    self.right = None
    self.cont = content

class Tree:

  def __init__(self):
    self.root = None
  
  def to_list(self):
    return Tree._sub_node_to_list(self.root)

  def get_leaves(self):
    return Tree._get_leaves(self.root)
      
  @staticmethod
  def _get_leaves(node: TreeNode):
    if node.left is None and node.right is None:
      return [node.cont]
    return [*Tree._get_leaves(node.left), *Tree._get_leaves(node.right)]

  @staticmethod
  def _sub_node_to_list(node: TreeNode):
    if node is None:
      return []
    return [*Tree._sub_node_to_list(node.left), node.cont, *Tree._sub_node_to_list(node.right)]

  def __len__(self):
    return Tree._count_nodes(self.root)
    
  @staticmethod
  def _count_nodes(node: TreeNode):
    if node is None:
      return 0
    return 1 + Tree._count_nodes(node.left) + Tree._count_nodes(node.right)

"""XTSTree Base"""

from collections.abc import Iterable
from typing import Callable, Optional
from statsmodels.tsa.stattools import adfuller

class XTSTree:
  
  def __init__(self, stop_condition:str='depth', stop_val=3, max_iter=1000, min_dist=50, params:dict={}):
    self.stop_condition = stop_condition
    self.stop_val = stop_val
    self.max_iter = max_iter
    self.min_dist = min_dist
    self.params = params
  
  def _depth_stop_condition(self, series: Iterable, depth:int):
    return depth >= (self.stop_val - 1)
  
  def _adf_stop_condition(self, series: Iterable, depth:int):
    adf = adfuller(series)
    return adf[1] < self.stop_val
  
  # Cria a árvore e acha os splits para uma série
  def create_splits(self, series: Iterable):
    if self.stop_condition == 'depth':
      stop_func=self._depth_stop_condition
    elif self.stop_condition == 'adf':
      stop_func=self._adf_stop_condition
    else:
      raise ValueError(f'Stop condition {self.stop_condition} not supported')
    xtstree = Tree()
    xtstree.root = self._recursive_tree(series, stop_func=stop_func, params=self.params)
    return xtstree

  # Função recursiva para encontrar os nós e criar a árvore
  def _recursive_tree(self, series: Iterable, stop_func: Callable[[Iterable, int], bool], params: dict, curr_depth=0):
    node = TreeNode(series)
    # Se a é pra parar, retorna o nó com o pedaço da série
    if stop_func(series, curr_depth):
      return node
    
    # Achando a posição de corte e pegando os parâmetros da função de corte
    # Isso permite que a função de corte altere os parâmetros pra chamada dos próximos nós para otimizar os cortes
    cut_pos, params = self._find_cut(series=series, params=params)
    
    # Se achou uma posição de corte, corta a série e procura na esquerda e na direita
    if cut_pos >= 0:
      node.left = self._recursive_tree(series[:cut_pos], stop_func=stop_func, params=params, curr_depth=curr_depth+1)
      node.right = self._recursive_tree(series[cut_pos:], stop_func=stop_func, params=params, curr_depth=curr_depth+1)
      
    # Retorna o nó
    return node
    
  # Função que encontra a posição de corte, única para cada método de corte
  def _find_cut(self, series: Iterable, params: dict) -> (int, dict):
    pass
    

"""Separadores - XTSTree"""

from skmultiflow.drift_detection import PageHinkley

class XTSTreePageHinkley(XTSTree):
  
  def __init__(self, stop_condition: str='depth', stop_val=2, max_iter=1000, min_dist=30, min_instances: int=30, delta: float=0.005, starting_threshold: float=50.0, alpha: float=1 - 0.0001):
    self.min_instances = min_instances
    self.delta = delta
    self.threshold = starting_threshold
    self.alpha = alpha
    super().__init__(stop_condition=stop_condition, stop_val=stop_val, max_iter=max_iter, min_dist=min_dist, params={'max_threshold': -1, 'threshold': self.threshold})

  def _find_cut(self, series: Iterable, params: dict):
    # Faz uma cópia dos parâmetros porque vai retornar uma cópia dos parâmetros alterados
    # A cópia é feita dentro da função de corte porque pode não precisar alterar os parâmetros dependendo do método de corte
    params = dict(params)
    
    # Threshold mínimo sempre é 0, máximo deve começar com -1 mas idealmente é alterado para otimizar a busca
    threshold = params['threshold']
    min_threshold = 0
    max_threshold = params['max_threshold']
    # Limitando o número de iterações pra um máximo
    for n_iter in range(self.max_iter):
      # Pra reforçar a distância mínima entre cortes, o número de instâncias mínimas até detectar mudança é colocado como a distância mínima, e a série é analisada até os último min_dist elementos.
      ph = PageHinkley(min_instances=self.min_dist, delta=self.delta, threshold=threshold)
      cut_pos = -1
      n_cuts = 0
      for i, val in enumerate(series[:-self.min_dist]):
        ph.add_element(val)
        if ph.detected_change():
          n_cuts += 1
          cut_pos = i
          # Se detectou mais de um corte, então tem que aumentar o threshold
          if n_cuts > 1:
            # Atualiza o threshold mínimo
            min_threshold = threshold
            # E faz a busca binária do threshold
            # Se for menor que 0 é porque não foi definido, então aumenta o threshold em 50%
            if max_threshold < 0:
              threshold += threshold/2
            else:
              threshold += (max_threshold - threshold)/2
            break
      if n_cuts == 1:
        # Achou apenas um corte, o threshold máximo para as próximas iterações vira o threshold atual porque thresholds maiores não vão retornar cortes nas séries cortadas
        params['max_threshold'] = threshold
        params['threshold'] = threshold/2
        return cut_pos, params
      elif n_cuts < 1:
        # Se não achou corte, o threshold máximo vira o atual e faz a busca binária no threshold
        max_threshold = threshold
        threshold -= (threshold-min_threshold)/2
    
    # Se estourar o máximo de iterações, retorna que não achou um corte ali
    print(f'Não achei um corte, tamanho da série {len(series)}, {threshold}, {n_cuts}')
    return -1, params

"""Testes"""

window_size = 96
# Multiplicador pra não deixar o desvio muito pequeno
# No cusum os limites recomendados são 4 desvios, com a folga de meio desvio dá mais ou menos isso
s = 3.2
min_std = 0
max_std = 15
# Valor inicial caso tenha anomalia desde o começo
std = min_std

series_path = '../../../Dados/por estacao/23025122/export_automaticas_23025122_umidrelmed2m.csv'

def seq_data(data, window_size=96):
  data_X = []
  data_Y = []
  for i in range(len(data) - (len(data) % window_size) - window_size):
    data_X.append(data[i:i+window_size])
    try:
      data_Y.append(data[i+window_size])
    except:
      (i+window_size)
  return np.array(data_X), np.array(data_Y)

from statsmodels.tsa.seasonal import seasonal_decompose

series_len = 15 * 96

# series = pd.read_csv(series_path, nrows=series_len)['umidrelmed2m']
series = pd.read_csv(series_path)['umidrelmed2m']
# series = [(math.sin(x/100)) for x in range(1000)] + [(math.sin(x/10)) for x in range(1000)]


series = np.array([series[i] if np.isfinite(series[i]) else series[i-1] for i in range(len(series))])

# print('Valor p (> 0.05, não estacionária, < 0.05 é estacionária) ', adfuller(series)[1])
# reshaped_data, targets = seq_data(series, window_size=window_size)
# standart_d = [max(min(np.std(x) * s, max_std), min_std) for x in reshaped_data]

series_diff = np.diff(series)

plot(series)
print('Criando splits')

adf = 0.05

t = time.perf_counter()
sep = XTSTreePageHinkley(stop_condition='adf', stop_val=adf, min_dist=30)

xtstree = sep.create_splits(series)
print(f'Splits achados em {time.perf_counter() - t}: ')

leaves = [len(leaf) for leaf in xtstree.get_leaves()] 

cuts = [sum([leaf for leaf in leaves[:i+1]]) for i in range(len(leaves))][:-1]

print(cuts)
plot(series, divisions=cuts, title=f'Cortes, threshold do adf {adf}')